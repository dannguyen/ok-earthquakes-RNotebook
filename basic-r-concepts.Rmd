---
title: "Part 2: Basic R Concepts"
author: "Dan Nguyen"
date: "August 17, 2015"
output:
  md_document:
    variant: markdown_github
---


## Necessary libraries

```{r, message = FALSE}
library(dplyr)
library(lubridate)
library(rgdal)
library(ggplot2)
```

```{r}
setwd('/tmp')
```


Load the earthquakes

```{r, message = FALSE}
url <- "http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv"
fname <- "all_month.csv"
if (!file.exists(fname)) download.file(url, fname)
usgs_data <- read.csv(fname, stringsAsFactors=FALSE)
```

### Filter data for earthquake events

Not all the data involves earthquakes:

```{r}
group_by(usgs_data, type) %>% summarise(count = n())
```

Filter for just earthquakes at least magnitude 2.0:

```{r}
quakes <- filter(usgs_data, type == 'earthquake', mag > 2.0)
```

## Date functions, adding columns

```{r}
quakes  <- mutate(quakes, day = day(time))
```

```{r, message = FALSE}
ggplot(quakes, aes(day)) + geom_histogram(binwidth = 1)
```


# Geographically filtering the data

## Download the map data

```{r, message = FALSE}
url <- "http://www2.census.gov/geo/tiger/GENZ2014/shp/cb_2014_us_state_5m.zip"
fname <- "cb_2014_us_state_5m.zip"
if (!file.exists(fname)) download.file(url, fname)
unzip(fname, exdir = "shp")
us <- readOGR("shp/cb_2014_us_state_5m.shp", "cb_2014_us_state_5m")
```

### Displaying the map and points

The map:


```{r, message = FALSE}
ggplot() + geom_polygon(data = us, aes(x = long, y = lat, group = group))
```


The points:


```{r, message = FALSE}
ggplot() + geom_point(data = quakes, aes(x = longitude, y = latitude), color = "red")
```

All together:

```{r, message = FALSE}
ggplot() +
  geom_polygon(data = us, aes(x = long, y = lat, group = group)) +
  geom_point(data = quakes, aes(x = longitude, y = latitude), color = "red")
```

A little better:

```{r, message = FALSE}
ggplot() +
  geom_polygon(data = us, aes(x = long, y = lat, group = group)) +
  geom_point(data = quakes, aes(x = longitude, y = latitude, size = mag),
              color = "red", alpha = 0.2, shape = 21)
```

From here on out, I won't be using `size = mag` because it doesn't add much. Plus it's inaccurate. Each step up in magnitude is an increase in force TK of 10, meaning the circle for magnitude 6 should 1000 times larger than for 3.

For this analysis, we care less about size of earthquakes and more about their frequency of occurrence.






## Adding a projection

The previous example is a little distorted, as the units for `lat` and `long` are not equal.

Using `coord_equal()` helps mitigate that, resulting in a wider graphic:


```{r, message = FALSE}
ggplot() +
  geom_polygon(data = us, aes(x = long, y = lat, group = group)) +
  geom_point(data = quakes, aes(x = longitude, y = latitude),
              color = "red", alpha = 0.2, shape = 21) +
  coord_equal()
```


But that doesn't quite work. TKTK

Working with projections should be one of the last steps in the process. But applying a more attractive projection to our map is a nice [segue to the batshit-hell-of-a-rabbit-hole that is cartography](https://source.opennews.org/en-US/learning/choosing-right-map-projection/).


As you know, our data displays are typically *flat* but the Earth is *spherical*, leading to a distorted . One way to mitigate this is to project, or translate, the coordinates onto a


```{r}
ggplot() +
  geom_polygon(data = us, aes(x = long, y = lat, group = group)) +
  geom_point(data = quakes, aes(x = longitude, y = latitude),
              color = "red", alpha = 0.2, shape = 21) +
  coord_map("ortho")
```

Let's make the map focused on America:

```{r}
ggplot() +
  geom_polygon(data = us, aes(x = long, y = lat, group = group)) +
  geom_point(data = quakes, aes(x = longitude, y = latitude),
              color = "red", alpha = 0.2, shape = 21) +
  coord_map("ortho",orientation=c(39, -98, 0))
```

The spherical display is neat but we're going to be focused on the U.S. and individual states, so we don't need as much spherical-simulation. So we'll use Albers:

https://rud.is/b/2015/03/15/simple-lower-us-48-albers-maps-local-no-api-citystate-geocoding-in-r/

```{r}
ggplot() +
  geom_polygon(data = us, aes(x = long, y = lat, group = group)) +
  geom_point(data = quakes, aes(x = longitude, y = latitude),
              color = "red", alpha = 0.2, shape = 21) +
  coord_map("albers", lat0 = 39, latl = -42)
```



## Filter the quakes data by geogrpahy

Going forward, we want to focus only on earthquakes in the United States, and ultimately, Oklahoma. Unfortunately, there's no column in the USGS earthquakes data that describes countries and states/provinces. The closest thing is the `place` column:

```{r}
head(quakes$place)
```

Theoretically, we could get most of the U.S. states by doing a complex query where we filter for rows in which `place` contains the name of one of the 50 United States. But that's cumbersome, and there are probably edge cases (such as `"Georgia"`) that we'd have to write even more cumbersome code for.

Instead, we can use our downloaded map data to essentially tell R: "filter for the earthquake points that fall within the boundaries of the polyons defined in `us`.". This is possible via the [__sp__ package](https://cran.r-project.org/web/packages/sp/sp.pdf), which is included as a dependency to [rgdal](https://cran.r-project.org/web/packages/rgdal/index.html).

The first step is to convert the `quakes` dataframe into a `SpatialPointsDataFrame`.

```{r}
sp_quakes <- SpatialPointsDataFrame(data = quakes,
                                         coords = quakes[,c("longitude", "latitude")])
```

Now that the earthquake data is "spatial data", it needs to concern itself with projection, too. We need to give it the same __projection__ as the `us` data.

```{r}
proj4string(sp_quakes) <- proj4string(us)
```

Because we haven't actually changed the projection of `uss` from when we first loaded the original map data (and the `coord_map()` call in the plotting process doesn't alter the underlying data), this doesn't actually change any of the coordinates in `sp_quakes`. But it's a neccesary step for this next step, which creates a subset of points from `sp_quakes` -- i.e. the points that fall within the polygons contained in `uss`, and assigns it to the variable `sp_us_quakes`:


```{r}
sp_us_quakes <- sp_quakes[us,]
```

How big of difference did that make? Let's count the rows:

In the full list of quakes:

```{r}
nrow(sp_quakes)
```

In the `uss`-filtered quakes:

```{r}
nrow(sp_us_quakes)
```

We can confirm this by plotting the map polygons and earthquake points. We'll use the same plotting code as before, but change the variable names of the `data` argument in `geom_point()`. Before I call `ggplot()`, I create a new variable, `us_quakes`, which is just `sp_us_quakes` converted from a SpatialPointsDataFrame to a plain data frame, because `geom_point()` doesn't know how to handle SpatialPointsDataFrames:

```{r}
us_quakes <- as.data.frame(sp_us_quakes)
```



```{r, message = FALSE}
ggplot() +
  geom_polygon(data = us, aes(x = long, y = lat, group = group)) +
  geom_point(data = us_quakes, aes(x = longitude, y = latitude),
              color = "red", alpha = 0.2, shape = 21) +
  coord_map("albers", lat0 = 39, latl = -42)
```

So the visualization now only shows earthquakes within the United States. However, the actual chart shows a large amount of empty space. That's because the furthest tip of Alaska is [both the most western *and* eastern point of the United States](https://en.wikipedia.org/wiki/Extreme_points_of_the_United_States), such that it wraps around to the other side (longitude of 179+).

We'll include Alaska when doing state-by-state earthquake counts. But for mapping beauty, let's remove it from our current plots.

### Adding state names to the quakes data

To remove Alaska, we need to remove both its geodata from `us` *and* its earthquakes from the `us_quakes` data. Let's start with using `subset()` to filter `us`.

The `us@data` object contains metadata about the geocordinates, including the "names" of the polygons, and additional attributes such as postal code:

```{r}
colnames(us@data)
```

The columns we care about are `GEOID`, `NAME`, and `STUSPS`:

```{r}
head(select(us@data, NAME, GEOID, STUSPS))
```

Using `subset()` to filter and assign the result to `uss`:

```{r}
uss <- subset(us, us$STUSPS != 'AK')
```

Now use `uss` to filter the earthquakes data:


```{r}
sp_us_quakes <- sp_quakes[uss,]
us_quakes = as.data.frame(sp_us_quakes)
```

And let's re-visualize:

```{r, message = FALSE}
ggplot() +
  geom_polygon(data = uss, aes(x = long, y = lat, group = group)) +
  geom_point(data = us_quakes, aes(x = longitude, y = latitude),
              color = "red", alpha = 0.2, shape = 21) +
  coord_map("albers", lat0 = 39, latl = -42)
```

Let's remove Alaska, Hawaii, and all the territories:

```{r}
uss <- subset(us, !(us$STUSPS %in% c('AK', 'HI', 'AS', 'GU', 'MP', 'PR', 'VI')))
us_quakes = as.data.frame(sp_quakes[uss,])
```

And the map of only the continental United States:

```{r, message = FALSE}
ggplot() +
  geom_polygon(data = uss, aes(x = long, y = lat, group = group)) +
  geom_point(data = us_quakes, aes(x = longitude, y = latitude),
              color = "red", alpha = 0.2, shape = 21) +
  coord_map("albers", lat0 = 39, latl = -42)
```


Much nicer. Let's try creating a subset of data for one state, such as California. We just have to change the condition passed into `subset()`:

```{r}
ca <- subset(us, us$STUSPS == 'CA')
ca_quakes = as.data.frame(sp_quakes[ca,])
```

And the map of just California and its quakes:

```{r, message = FALSE}
ggplot() +
  geom_polygon(data = ca, aes(x = long, y = lat, group = group)) +
  geom_point(data = ca_quakes, aes(x = longitude, y = latitude),
              color = "red", alpha = 0.6, shape = 21) +
  coord_map("albers", lat0 = 39, latl = -42)
```
